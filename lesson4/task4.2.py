# 2. Написать два алгоритма нахождения i-го по счёту простого числа.
# Без использования «Решета Эратосфена»;
# Используя алгоритм «Решето Эратосфена»
# Примечание ко всему домашнему заданию: Проанализировать скорость и сложность алгоритмов.
# Результаты анализа сохранить в виде комментариев в файле с кодом.

import cProfile


def without_sieve(n):
    # n = int(input('n = '))  # вводим n
    lst = []  # создаем список для хранения простых чисел (пока пустой)
    k = 0  # создаем переменную для хранения кол-ва делителей
    for i in range(2, n + 1):  # проходим по всем числам до n включительно
        for j in range(2, i):  # проходим по всем числам до текущего
            if i % j == 0:  # ищем делители
                k = k + 1  # выясняем количество делителей
        if k == 0:  # если делителей нет
            lst.append(i)  # добавляем число в список
        else:
            k = 0
    print(lst)


without_sieve(10000)

cProfile.run('without_sieve(10000)')

# 1234 function calls in 2.504 seconds



def sieve_eratosthenes(n):
    a = []  # создаем пустой список
    for i in range(n + 1):
        a.append(i)  # с помощью цикла заполняем его значениями от 0 до n
    a[1] = 0  # второй элемент еденица, её не считают простым числом, поэтому присваиваем ей значение 0
    i = 2  # начинаем итерацию с 3-го элемента
    while i <= n:  # если в этой ячейке не ноль, значит это простое число
        if a[i] != 0:
            j = i + i
            while j <= n:
                a[j] = 0
                j = j + i
        i += 1
    a = set(a)
    a.remove(0)
    print(a)


sieve_eratosthenes(10000)

cProfile.run('sieve_eratosthenes(10000)')

# 10007 function calls in 0.004 seconds


